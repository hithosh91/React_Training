1.why react js?
react js is a javascript Library 
component based architecture-- resuablity and maintainable to easier to debug
virtual dom --faster rendering --update only where the parts are changed
Unidirectional Data flow: 

2.What is UseState?
state is away to store and manage information in component that can change over time

it is a hook provided by react to enable state in functional component


3.What is hoisting?
variable and fucntion   declarations are moved to the top of their scoped during compiled phasee
  variabel:
  console.log(x); // Output: undefined
var x = 5;
console.log(x); // Output: 5

console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;
The declaration let y is hoisted, but it's in a "temporal dead zone" until the actual declaration is encountered, leading to a ReferenceError.

4.use Strict
secure code , human error / It prevents the use of undeclared variables, disallows duplicate parameter names,  dont reffer window object

"use strict"

let x=10;    x=10
console.log(x)

5. difference between  === && ==

== is compare the value
=== is compare value and data type

6.what is difference between let var and const?

var is functional scope and it has hoisting
where as let is block level scope
const is block level scoep and while declare it must be instiallised

7. event loop?
it is a single threaded ,non-blocking asynchronous concurrent language  means handle multiple operation at the same time despite have single threaded
call stack--synchronous  code--tract function call , when functionis called added to stack when its is completed it is removed from the stack


web api: asynchronous operation --example setTimeout

callback queue --whe an asynchronous operation is completed its callback function is added to callback quess

console.log('Start');

setTimeout(() => {
  console.log('Timeout callback');
}, 2000);

console.log('End');

8.rest and spread operator?
9.call blind and apply

10.var str=""
str?console.log("yes"):console.log("No")
var str=" "
str?console.log("yes"):console.log("No")
12.
let obj = { x: 10, y: 20 };
let { x, z = 30 } = obj;
console.log(x, z);
13.
setTimeout(() => {
  console.log("Hello from setTimeout");
}, 0);
console.log("This will be logged first");
13.
let numbers = [1, 2, 3, 4, 5];

numbers=numbers.map(num => num * 2)



14.
console.log(x);
var x = 10;
15.
function test() {
  console.log(y);
  var y = 5;
}
test();
function test() {
  console.log(x);
  var x;
  x = 5;
}
test();
16.
console.log(a);
function a() {
  console.log("Inside a");
}
17.
function outer() {
  var x = 10;
  function inner() {
    console.log(x);
  }
  inner();
}
outer();
18.
function outer() {
  var x = 10;
  function inner() {
     var y=9
    console.log(x);
  }
  inner();
  console.log(y)
}
outer();


console.log(x); // Output: undefined
console.log(y); // Output: ReferenceError

var x = 10;
let y = 20;

19.
const person = {
    name: 'Alice',
    greet: function() {
        console.log('Hello, my name is ' + this.name);
    }
};
person.greet();
20.
console.log(this)
const person = {
    name: 'Alice',
    greet: function() {
        console.log('Hello, my name is ' + this.name);
    }
};

21.
person.greet();


function greet() {
    console.log(this); 
greet()
22.
function Person(name) {
    this.name = name;
}
const person1 = new Person('Bob');
console.log(person1.name); // Output: Bob

24>difference between  apply, call, and bind in JavaScript

apply
The apply method lets you call a function and explicitly set what this should refer to within that function. You provide the this value and an array of arguments.

Example:

javascript
Copy code
function introduce(greeting, punctuation) {
    console.log(greeting + ', my name is ' + this.name + punctuation);
}

const person = { name: 'Alice' };

introduce.apply(person, ['Hello', '!']); // Output: Hello, my name is Alice!
Here, apply calls the introduce function and sets this to person, and uses ['Hello', '!'] as the arguments.

call
The call method is very similar to apply, but instead of passing an array of arguments, you pass them individually.

Example:

javascript
Copy code
introduce.call(person, 'Hello', '!'); // Output: Hello, my name is Alice!
This does the same thing as apply, but the arguments are provided one by one.

bind
The bind method creates a new function that, when called, has this set to the value you provide. Unlike apply and call, it doesn't call the function immediately. Instead, it returns a new function that can be called later.

Example:

javascript
Copy code
const boundIntroduce = introduce.bind(person);
boundIntroduce('Hello', '!'); // Output: Hello, my name is Alice!
Here, bind creates a new version of the introduce function where this is always person. You can call boundIntroduce later with the arguments.

Why Are These Useful?
Consistency: They ensure that this refers to the correct object, no matter where or how the function is called.
Flexibility: You can borrow methods from one object and use them with another.
Callbacks: In event handlers or asynchronous code, this can often change. bind helps keep this consistent.
For example, if you're working with a button click handler in a web app:

javascript
Copy code
const button = document.querySelector('button');

const person = {
    name: 'Alice',
    sayHello: function() {
        console.log('Hello, my name is ' + this.name);
    }
};

button.addEventListener('click', person.sayHello.bind(person));
In this code, when the button is clicked, sayHello is called with this correctly set to person, 